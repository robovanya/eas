/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package eoc.calendar;

import eoc.EOC_message;
import eoc.IEOC_Object;
import eoc.xinterface.*;
import eoc.IEOC_VisualObject;
import eoc.database.DBconnection;
import eoc.widgets.*;
import system.Kernel;
import system.FnEaS;
import java.awt.event.FocusListener;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JPanel;
import system.perm.PermHandler;

/**
 *
 * @author rvanya
 */
public class XD_calendar_event extends javax.swing.JDialog implements eoc.IEOC_VisualObject {

    private eoc.IEOC_VisualObject parentContainer; 
    public IEOC_Object myObjectID;
    private PermHandler permHandler;
    public Kernel krn;
    public DBconnection MyCn;
    public boolean bInitialized;
    public JPanel myJPanel;
    private String usrPerms = ""; // "NOKT-V"
    private String objPerms = "NUDP";
    private String perms = "";
    private int connectionStatus;
    private String sEOCobjectType = "<EOC_DObject_type_not_defined>";
    private CalendarOwner currCalendarOwner;
    private TimeChunk     currTimeChunk;
    private CalendarEvent currCalendarEvent;
    private boolean isUpdatedAfterView = false;

    
    //    private Map<String, String> properties = new HashMap<String, String>();
    private Map<String, String> properties = new HashMap<>();
    private final Map<String, String> privateData = new HashMap<>();
    /**
     * Creates new form EOC_DObject
     * @param parent
     * @param modal
     * @param kr
     */
    public XD_calendar_event(java.awt.Frame parent, boolean modal, Kernel kr,
                             CalendarOwner calOwner, TimeChunk tmChunk) {
        super(parent, modal);
        krn = kr;
        initComponents();
        this.setEOC_objectType("EOC_DObject");
        setModalityType(java.awt.Dialog.ModalityType.APPLICATION_MODAL);
        // setLocationByPlatform(true);
        setLocationRelativeTo(parent);
        owner_source1.setSingleCalendar(true);
        owner_source1.setUpdateMode(false,false,false);
        
    }
    
    public XD_calendar_event() {
          super();
    }
    
    public void initializeAs(IEOC_VisualObject parent, boolean modal) {
        this.setParentContainer(parent);
        this.setModal(modal);
         initComponents();
        this.setEOC_objectType("EOC_DObject");
        setModalityType(java.awt.Dialog.ModalityType.APPLICATION_MODAL);
    }
    /**
     * This method is called from within the constructor to initialize the form. WARNING:
     * Do NOT modify this code. The content of this method is always regenerated by the
     * Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        owner_source1 = new eoc.calendar.Pnl_owner_source();
        event_updater1 = new eoc.calendar.Pnl_event_updater();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Zadávanie/úprava udalostí ");
        setMinimumSize(new java.awt.Dimension(600, 630));
        setModal(true);
        setPreferredSize(new java.awt.Dimension(600, 630));
        getContentPane().add(owner_source1, java.awt.BorderLayout.PAGE_START);
        getContentPane().add(event_updater1, java.awt.BorderLayout.CENTER);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(DObject.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(DObject.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(DObject.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(DObject.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the dialog */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                DObject dialog = new DObject(new javax.swing.JFrame(), true);
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
                    @Override
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }
    public String getProp(String key) {
        return properties.get(key);
    }

    public void setProp(String key, String value) {
        properties.put(key, value);
    }

    public void delProp(String key) {
        properties.remove(key);
    }

    public String getUsrPerms() { return usrPerms;}

    public String getObjPerms() { return objPerms;}

    public String getPerms() { return perms;}
    
    public void countPerms() {
       perms = "";
       if (objPerms.contains("N") && usrPerms.contains("N")) {
          perms = perms + "N";
       }
       if (objPerms.contains("O") && usrPerms.contains("O")) {
          perms = perms + "O";
       }
       if (objPerms.contains("C") && usrPerms.contains("N")) {
          perms = perms + "C";
       }
       if (objPerms.contains("T") && usrPerms.contains("T")) {
          perms = perms + "T";
       }
       if (objPerms.contains("D") && usrPerms.contains("D")) {
          perms = perms + "D";
       }
    }

    @Override
    public String initialize(Kernel krnl, DBconnection cnX) {
        if (bInitialized) return "";
        this.setKrn(krnl);
        this.setConn(cnX);
        setMyObjectID(this);
        createPermHandler(krn, myObjectID);
        owner_source1.initialize(krnl, cnX);
        event_updater1.initialize(krnl, cnX);
        event_updater1.setDialogBox(this);
        bInitialized = true;
        return "";
    }
    @Override
    public String destroy() {
        /* sem by mal ist napriklad test na existenciu 
           necommitnutej transakcie, a osetrenie tohoto stavu */
        try {
            this.finalize();
        } catch (Throwable ex) {
            Logger.getLogger(eoc.IEOC_VisualObject.class.getName()).log(Level.SEVERE, null, ex);
        }
        return "";
    }

    @Override
    public DBconnection getConn() {
        return MyCn;
    }

    @Override
    public String sendMessage(eoc.EOC_message msg,String sLinkType, String sVector) {
       return krn.krn_sendMessage(myObjectID, msg, sLinkType, sVector);
    }

    // prijimac sprav od cudzich objektov
    @Override
    public String receiveMessage(eoc.EOC_message eocMsg) {

        // musi byt ako prva instrukcia v metode !!!
        if (eocMsg==null) return FnEaS.nullEocMessageResponse(myObjectID);
        
                // standardne hlasenie metody
       krn.debugOut(this,5,this.getClass().getName() + " EOC_VObject-Receiving message: "  
                         + eocMsg.getMessage() + " s parametrami: " + eocMsg.getParameters());
       //krn.krnMsg(this.getClass().getName() + " ** 1a PICABAAAA - EOC_VisualObject-Receiving message: "  
       //                  + sMessage + " s parametrami: " + sParameters);
       String retVal = "NOTRECEIVED-in_XD_calendar_event_Object";
       try {
          // ziskanie vhodnej metody
          Method mtd;
          mtd = FnEaS.getEocMessageMethod(myObjectID, eocMsg);
         // krn.krnMsg(this.getClass().getName() + " ** 1b EOC_VisualObject-Receiving message: "  
         //                + sMessage + " s parametrami: " + sParameters + " mtd-is-null=" + (mtd==null));

          try {
             if (mtd != null) {
                if (!mtd.getReturnType().toString().equals("class java.lang.String")
                    && !mtd.getReturnType().equals(Void.TYPE)) {
                   krn.Message(this, "W", 
                              "Vrátená hodnota nie je typu 'String'", mtd.getName());
                }
                mtd.setAccessible(true);
                if (eocMsg.getParameters() == null) {
                   retVal = (String) mtd.invoke(this);
                }
                else {
                   retVal = (String) mtd.invoke(this,eocMsg.getParameters());
                }
                if (retVal==null) {retVal = ""; } // asi je metoda typu void
                return retVal;
//krn.krnMsg(this.getClass().getName() + " ** 3a PICABAAAA - EOC_VisualObject-Receiving message: " + retVal);
       //krn.krnMsg(this.getClass().getName() + " ** 2a EOC_VisualObject-Receiving message: "  
           //              + sMessage + " s parametrami: " + sParameters + " RVL=" + retVal
           //     + " mtd-is-null=" + (mtd==null));
             }
/*
             // hladanie a spustenielokalnej verzie receiveMessage, pokial existuje
             mtd = FnEaS.getLocalReceiveMessageMethod(myObjectID);
         //krn.krnMsg(this.getClass().getName() + " ** 2b EOC_VisualObject-Receiving message: "  
         //                + sMessage + " s parametrami: " + sParameters + " RVL=" + retVal);
           if (mtd!=null) {
                 String locRetVal;
                 mtd.setAccessible(true);
                 locRetVal = (String) mtd.invoke(eocMsg.getSender(),eocMsg.getMessage(),eocMsg.getParameters(),eocMsg.getOthers());
                 if (locRetVal!=null) { retVal = retVal + locRetVal; }
             }
       krn.Message(this.getClass().getName() + " ** 3 EOC_VObject-Receiving message: "  
                         + eocMsg.getMessage() + " s parametrami: " + eocMsg.getParameters() + " RVL=" + retVal);
             return retVal;
*/             
          } catch (IllegalAccessException ex) {
             krn.debugOut(this,0,"VObject " + ex.toString());
             return "NOTRECEIVED-VObject=SUPER-IllegalAccessException=" + eocMsg.getMessage();
          } catch (IllegalArgumentException ex) {
             krn.debugOut(this,0,"VObject " + ex.toString());
             return "NOTRECEIVED-VObject=SUPER-IllegalArgumentException=" + eocMsg.getMessage();
          } catch (InvocationTargetException ex) {
             krn.debugOut(this,5,"VObject " + ex.toString()
                     + "\n>>>==== to je ON ====>>>" + ex.getTargetException());
             return "NOTRECEIVED-VObject=SUPER-InvocationTargetException=" + eocMsg.getMessage();
          }
       } catch (SecurityException ex) {
          return "NOTRECEIVED-VObject=SUPER-SecurityException=" + eocMsg.getMessage();
       }
       finally {
          // return "";
       }
       return retVal;
    }

    @Override
    public String setConn(DBconnection cX) {
        this.MyCn = cX;
        return "";
     }

    @Override
    public String setKrn(Kernel krnl) {
         this.krn = krnl;
         return "";
    }

   
  /*     public void setMyTable(JPanel jFrm) {
        myJPanel = jFrm;
    }
*/

    @Override
    public void setMyObjectID(eoc.IEOC_Object evo) {
        myObjectID = evo;
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private eoc.calendar.Pnl_event_updater event_updater1;
    private eoc.calendar.Pnl_owner_source owner_source1;
    // End of variables declaration//GEN-END:variables

    @Override
    public void setConnectionStatus(int status) {
         connectionStatus = status;
    }

    @Override
    public String afterInitialize() {
        return "";
    }

    @Override
    public void setParentContainer(eoc.IEOC_VisualObject cntnr) {
            parentContainer = cntnr; 
    }

    @Override
    public boolean isContainer() {
        return true;
    }

    @Override
    public String CallMethod (Object oCaller, String sMethod, String sParameters) {
        return krn.CallMethod(oCaller,this,sMethod,sParameters);
    }

    public void setEOC_objectType(String sObjectType) {
        sEOCobjectType = sObjectType;
    }

    public String getEOC_objectType() {
      return "EOC_VObject";
   }

    @Override
    public Map<String, String> saveFrameToDef() {
        return krn.saveFrameToDef(this);
    }

    @Override
    public void restoreFrameFromDef(Object oPanel, Map<String, String> defMap) {
        krn.restorFrameFromDef(oPanel, defMap);
    }
    @Override
    public void setPrivateData(String key, String val) {
        privateData.put(key, val);
    }

    @Override
    public String getPrivateData(String key) {
        return privateData.get(key);
    }

    @Override
    public eoc.IEOC_VisualObject getParentContainer() {
        return parentContainer;
    }

    @Override
    public FocusListener getMyFocusListener() {
        FocusListener[] fl = this.getFocusListeners();
        return fl[0];
    }

    @Override
    public String createLinkTo(Object oCreator, Object oVSrc, Object oVTrg, String sLink, String sState) {
         throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void setVisible(boolean b) {
             super.setVisible(b); //To change body of generated methods, choose Tools | Templates.
    }

    
    public void view(CalendarEvent calEvt, String txnType) {
        currCalendarEvent = calEvt;
        owner_source1.goToOwner(calEvt.myOwner);
        event_updater1.setCalendarEvent(currCalendarEvent);
        event_updater1.setTxnType(txnType);
        pack();
        setVisible(true); 
    }
    
    public boolean view(CalendarOwner calOwnr, TimeChunk tmChunk,
                     Integer evtId, String txnType) {
        boolean isUpdated = false;
        System.out.println("xd_calendar_event viewing !1"
                        + "\n CalendarOwner: " + (calOwnr == null)
                        + "\n TimeChunk=" + (tmChunk == null)
                        + "\n eventID=" + (evtId==null?"<NULL>":evtId.toString())
        );
        // spracovanie parametrov pred vynorenim objektu        
                System.out.println("xd_calendar_event viewing with:" 
                        + "\n CalendarOwner: " + calOwnr.toString()
                        + "\n TimeChunk=" + tmChunk.toString()
                        + "\n eventID=" + (evtId==null?"<NULL>":evtId.toString()));
        System.out.println("xd_calendar_event viewing !2");
//                vallamii szet van baszkervalva !!! Kurva eletbe
         // ked je id prazdny, jedna sa o zadanie noveho dokladu
////         if (evtId == null || evtId <= 0) {
             currCalendarEvent = new CalendarEvent(krn, MyCn, calOwnr, tmChunk, evtId);
             owner_source1.goToOwner(currCalendarEvent.myOwner);
             event_updater1.setCalendarEvent(currCalendarEvent);
////         }
         isUpdated = false;
         event_updater1.setTxnType(txnType);
         pack();
         setVisible(true); 
         System.out.println("POVIJEVVI");
         return isUpdatedAfterView;
    }
    
    public void setIsUpdatedAfterView(boolean val) {
        isUpdatedAfterView = val;
    } 

    @Override
    public PermHandler getPermHandler() {
        return permHandler;
    }

    @Override
    public String objectPermsChanged(EOC_message eocMsg) {
        permHandler.setObjPerms(eocMsg);
        return "";
    }

    @Override
    public String userPermsChanged(EOC_message eocMsg) {
        permHandler.setUsrPerms(eocMsg);
        return "";
    }

    public void createPermHandler(Kernel kr, IEOC_Object ieo) {
        permHandler = new PermHandler(kr, ieo);
    }

    @Override
    public void setObjPerms (EOC_message eocMsg) {
       permHandler.setObjPerms(eocMsg);
    }
    
    @Override
    public void setUsrPerms (EOC_message eocMsg) {
       permHandler.setUsrPerms(eocMsg);
    }
    
}
